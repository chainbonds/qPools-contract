use anchor_lang::prelude::*;
use anchor_lang::solana_program::program_option::COption;
use anchor_lang::solana_program::system_program;
use anchor_spl::token::{self, Mint, MintTo, Token, TokenAccount, Transfer};
use anchor_spl::associated_token::{self};

use amm::program::Amm;
use amm::cpi::accounts::RemovePosition;
use amm::cpi;

use crate::ErrorCode;
use crate::state::BondPoolAccount;
use crate::utils::functional::calculate_redeemables_to_be_distributed;

//use amm::{self, Decimal, Tickmap, State, Pool, Tick, Position, PositionList};
use amm::{self, Decimal};
// Anything generated by the invariant pool pda violates the seed constraints..
// whic hmake sense

#[derive(Accounts)]
// #[instruction(amount)]
#[instruction(
    _position_bump: u8,
    _bump_bond_pool_account: u8,
    position_index: i32,
    lower_tick_index: i32,
    upper_tick_index: i32
)]
pub struct CloseLiquidityPosition<'info> {

    #[account(signer, mut)]
    pub initializer: AccountInfo<'info>,
    pub state: AccountInfo<'info>,
    #[account(mut)]
    pub removed_position: AccountInfo<'info>,
    #[account(mut)]
    pub last_position: AccountInfo<'info>,
    #[account(mut)]
    pub pool: AccountInfo<'info>,
    #[account(mut)]
    pub position_list: AccountInfo<'info>,
    #[account(mut)]
    pub bond_pool_currency_token_mint: AccountInfo<'info>,
    #[account(
        mut,
        seeds=[bond_pool_currency_token_mint.key.as_ref(), b"bondPoolAccount1"],
        bump = _bump_bond_pool_account
    )]
    pub owner: AccountInfo<'info>,
    #[account(mut)]
    pub tickmap: AccountInfo<'info>,
    #[account(mut)]
    pub lower_tick: AccountInfo<'info>,
    #[account(mut)]
    pub upper_tick: AccountInfo<'info>,
    #[account(mut)]
    pub token_x: AccountInfo<'info>,
    #[account(mut)]
    pub token_y: AccountInfo<'info>,
    #[account(mut)]
    pub account_x: AccountInfo<'info>,
    #[account(mut)]
    pub account_y: AccountInfo<'info>,
    #[account(mut)]
    pub reserve_x: AccountInfo<'info>,
    #[account(mut)]
    pub reserve_y: AccountInfo<'info>,
    pub program_authority: AccountInfo<'info>,
    #[account(address = token::ID)]
    pub token_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
    pub invariant_program: Program<'info,Amm>,
}

pub fn handler(
    ctx: Context<CloseLiquidityPosition>,
    _position_bump: u8,
    _bump_bond_pool_account: u8,
    position_index: u32,
    lower_tick_index: i32,
    upper_tick_index: i32
) -> ProgramResult {
    msg!("Removing reserve to pools!");

    let create_position_accounts = RemovePosition {
        state: ctx.accounts.state.to_account_info(),
        removed_position: ctx.accounts.removed_position.to_account_info(),
        position_list: ctx.accounts.position_list.to_account_info(),
        // What is this last position thingy?
        last_position: ctx.accounts.last_position.to_account_info(),
        pool: ctx.accounts.pool.to_account_info(),
        tickmap: ctx.accounts.tickmap.to_account_info(),
        lower_tick: ctx.accounts.lower_tick.to_account_info(),
        upper_tick: ctx.accounts.upper_tick.to_account_info(),
        owner: ctx.accounts.owner.to_account_info(),
        token_x: ctx.accounts.token_x.to_account_info(),
        token_y: ctx.accounts.token_y.to_account_info(),
        account_x: ctx.accounts.account_x.to_account_info(),
        account_y: ctx.accounts.account_y.to_account_info(),
        reserve_x: ctx.accounts.reserve_x.to_account_info(),
        reserve_y: ctx.accounts.reserve_y.to_account_info(),
        program_authority: ctx.accounts.program_authority.to_account_info(),
        token_program: ctx.accounts.token_program.to_account_info(),

        // payer: ctx.accounts.initializer.to_account_info(),
    };
    let invariant_program = ctx.accounts.invariant_program.to_account_info();

    amm::cpi::remove_position(
        CpiContext::new_with_signer(
            invariant_program,
            create_position_accounts,
            &[
                [
                    ctx.accounts.bond_pool_currency_token_mint.key().as_ref(), b"bondPoolAccount1",
                    &[_bump_bond_pool_account]
                ].as_ref()
            ]
        ),
        // Why does it ask for a stupid u32?
        position_index,
        lower_tick_index,
        upper_tick_index
    )?;


    // // Calculate how much currency is in the bond
    // let available_currency: u64 = ctx.accounts.bond_pool_currency_account.amount;
    //
    // // For now, assume we provide the same amount of liquidity to all pools
    // // So we don't have to calculate the weightings
    // let fraction_per_pool = calculate_amount_per_pool(available_currency);
    //
    // // Make swaps, and deposit this much to the pool
    // for i in 0..fraction_per_pool.len() {
    //
    // }

    Ok(())
}